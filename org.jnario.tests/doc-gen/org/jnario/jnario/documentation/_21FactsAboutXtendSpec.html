<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>21 Facts about Xtend</title>
<meta name="description" content="">
<meta name="author" content="Jnario">

<!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
<!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

<!-- Le styles -->
<link rel="stylesheet" href="../../../..//css/bootstrap.min.css">
<link rel="stylesheet" href="../../../..//css/bootstrap-responsive.min.css">
<link rel="stylesheet" href="../../../..//css/custom.css">
<link rel="stylesheet" href="../../../..//css/prettify.css">
<script type="text/javascript" src="../../../..//js/prettify.js"></script>
<script type="text/javascript" src="../../../..//js/lang-jnario.js"></script>
</head>

<body onload="prettyPrint()">
	<div class="container">
		<div class="content">
			<div class="page-header">
				<h1>21 Facts about Xtend</h1>
			</div>
			<div class="row">
				<div class="span12">
<p>This document teaches you everything you need to know about Xtend in order to successfully use <a href="http://www.jnario.org">Jnario</a>. For a more detailed introduction see the offical <a href="http://www.eclipse.org/xtend/documentation.html">Xtend documentation</a>.</p>
<h3 id="A_modernized_Java">A modernized Java</h3>
<p><p>The syntax of Xtend is quite similar to Java, but Xtend code is usually a lot shorter than its Java counterpart. However, there are some important differences between Java and Xtend one should be aware of!</p>
</p>
<ul><li><p  id="No_semicolons"><strong>No semicolons</strong>
<p>Semicolons are optional in Xtend.</p>
<pre class="prettyprint lang-spec">
var greeting = ""
greeting = "Hello World"
println(greeting)</pre>
</p>
</li><li><p  id="Declare_variables_with_var_and_val"><strong>Declare variables with var and val</strong>
<p>Variable declarations are preceded by <code>var</code> or, for in case of final variables, by <code>val</code>.</p>
<pre class="prettyprint lang-spec">
var String x = "I might change" 
val String y = "I'll never change" // final</pre>
</p>
</li><li><p  id="Less_typing_thanks_to_type_inference"><strong>Less typing thanks to type inference</strong>
<p>Having to precede variable declarations with <code>var</code> or <code>val</code> seems like a step backwards at first glance, but the type of a variable can be inferred from the expression on the right-hand side. This means we can omit the type information for variable declarations, which makes code a lot more readable.</p>
<pre class="prettyprint lang-spec">
val greeting = "Hello World"
greeting =&gt; typeof(String)

val greetings = newHashMap(
  "german"  -&gt; "Hallo",
  "english" -&gt; "Hello"
)
greetings =&gt; typeof(HashMap)</pre>
</p>
</li><li><p  id="Syntactic_sugar__Pairs"><strong>Syntactic sugar: Pairs</strong>
<p>In case you are wondering what the <code>-&gt;</code> does in the previous example, it is syntactic sugar for a tuple:</p>
<pre class="prettyprint lang-spec">
val pair = "spain" -&gt; "italy"
pair.key   =&gt; "spain"
pair.value =&gt; "italy"</pre>
</p>
</li><li><p  id="Accessing_static_members_is_different_"><strong>Accessing static members is different!</strong>
<p>Static class members are accessed via <code>::</code> and not <code>.</code> like in Java.</p><p><span class="label label-warning">Important</span> This is probably the most often asked question on the Xtend <a href="https://groups.google.com/forum/?fromgroups#!forum/xtend-lang">mailing list</a>.</p>
<pre class="prettyprint lang-spec">
val colors = list("red", "blue", "green")
Collections::sort(colors)
colors =&gt; list("blue", "green", "red")</pre>
</p>
</li><li><p  id="Accessing_types"><strong>Accessing types</strong>
<p>Accessing classes has also a different syntax in Xtend. Instead of writing <code>String.class</code> like in Java, you need to write <code>typeof(String)</code> in Xtend.</p><p><span class="label label-warning">Important</span> This is probably the second most most often asked question on the Xtend mailing list.</p>
<pre class="prettyprint lang-spec">
typeof(String).name =&gt; "java.lang.String"</pre>
</p>
</li><li><p  id="Casts_have_a_different_syntax"><strong>Casts have a different syntax</strong>
<p>Type casts behave exactly like in Java, but have a slightly more readable syntax:</p>
<pre class="prettyprint lang-spec">
val Object obj = "a string"
val String s = obj as String</pre>
</p>
</li><li><p  id="Fields___methods_work_almost_like_in_Java"><strong>Fields & methods work almost like in Java</strong>
<p>Fields in Xtend can be declared exactly like in Java. Methods in Xtend are also declared like in Java, but with the difference that method declarations are preceded with <code>def</code>:</p>
<pre class="prettyprint lang-spec">
String greeting = "Hello "

def public String sayHello(String name){
  return greeting + name
}
</pre><p>The type inference also works for fields and methods. You can omit the return type of methods and the type of fields. Methods are by default public. So declaring fields and methods becomes a lot more concise:</p>
<pre class="prettyprint lang-spec">
val greeting = "Hello "

def sayHello(String name){
  greeting + name // return is optional
}
</pre><p>Calling fields and methods works exactly like in Java, but it is possible to omit the parentheses when calling a method without parameters.</p>
<pre class="prettyprint lang-spec">
sayHello("Sebastian") =&gt; greeting + "Sebastian"
42.toString =&gt; "42"</pre>
</p>
</li></ul>
<h3 id="The_Uber_Switch_Expression">The Uber-Switch Expression</h3>
<p><p>Xtend's switch expression is greatly improved over the one from Java. There is no fall through which means only one case is evaluated at most and is not limited to certain values but can be used for any object.</p>
</p>
<ul><li><p  id="Supports_case_expressions"><strong>Supports case expressions</strong>
<pre class="prettyprint lang-spec">
val myString = "Hello"

switch myString {
  case myString.length &gt; 5 : "a long string."
  case 'some'              : "It's some string."
  default                  : "It's another short string."
} 

=&gt;  "It's another short string."</pre>
</p>
</li><li><p  id="___and_type_guards__with_type_inference_"><strong>...and type guards [with type inference]</strong>
<p>You can also write type guards in the case statements. Note that on the right-hand side of the case statement you can directly access the features of the guarded type without an explicit cast;</p>
<pre class="prettyprint lang-spec">
val x = list(1, 2, 3) as Object

switch x {
  String case x.length &gt; 0 : x.length // length from String 
  List&lt;?&gt;                  : x.size    // size from List
  default : -1
} 

=&gt; 3</pre>
</p>
</li></ul>
<h3 id="Readable_Code_with_Extension_Methods">Readable Code with Extension Methods</h3>
<p><p>Extension methods allow adding new methods to existing types without modifying them. When writing specs this is really helpful as they can greatly improve the readability.</p>
</p>
<ul><li><p  id="Import_static_extension_methods_"><strong>Import static extension methods.</strong>
<p>You can import static methods as extensions, for example, when we import:</p>
<pre class="prettyprint lang-spec">
import static extension java.util.Collections.
</pre><p>we can directly call the imported static methods on our list objects:</p>
<pre class="prettyprint lang-spec">
val colors = list("red", "blue", "green")
colors.sort // sort is implemented by Collections#sort(List&lt;T&gt;)
colors =&gt; list("blue", "green", "red")</pre>
</p>
</li><li><p  id="Local_extension_methods_"><strong>Local extension methods.</strong>
<p>All visible non-static methods of the current class and its super types are automatically available as extensions. In specs this can be used to write custom matcher:</p>
<pre class="prettyprint lang-spec">
def hasOneElement(List<?> list){
	list.size == 1
}
</pre><p>We can then use this method in our assertion:</p>
<pre class="prettyprint lang-spec">
assert list("red").hasOneElement</pre>
</p>
</li><li><p  id="Extension_fields"><strong>Extension fields</strong>
<p>By adding the extension keyword to a field declaration, its instance methods become extension methods. We use this feature a lot to share helper methods or setup and tear-down operations between different specs. For example, we could move our <code>hasOneElement</code> method to a separate helper class <code>ListHelpers</code> and declare it as an extension field:</p>
<pre class="prettyprint lang-spec">
extension ListHelpers = new ListHelpers
</pre><p>Then we can share our helper between different specs, but can still use the provided methods as extensions:</p>
<pre class="prettyprint lang-spec">
assert list("red").hasOneElement</pre>
</p>
</li></ul>
<h3 id="Functional_Programming_FTW">Functional Programming FTW</h3>
<p></p>
<ul><li><p  id="Simple_access_to_list_elements"><strong>Simple access to list elements</strong>
<p>Accessing elements in lists.</p>
<pre class="prettyprint lang-spec">
val colors = list("red", "blue", "green")
colors.head =&gt; "red"
colors.tail =&gt; iterable("blue", "green")
colors.last =&gt; "green"
colors.empty =&gt; false</pre>
</p>
</li><li><p  id="Concatenate_collections_with__"><strong>Concatenate collections with +</strong>
<p>Here is another useful fact about Xtend, you can concatenate collections using the <code>+</code> operator.</p>
<pre class="prettyprint lang-spec">
list("red", "blue") + list("yellow", "green") =&gt; iterable("red", "blue", "yellow", "green")</pre>
</p>
</li><li><p  id="Concise_Lambda_Expressions"><strong>Concise Lambda Expressions</strong>
<pre class="prettyprint lang-spec">
// declaring a function object
var (String)=&gt;String shout 
// explicitly defining the parameter with type
shout = [String s | s.toUpperCase] 
// omit the type
shout = [s | s.toUpperCase] 
// using the implicit variable 'it' for lambdas with one parameter
shout = [it.toUpperCase] 
// but you can also omit the 'it'
shout = [toUpperCase] 
// apply the function to an object
shout.apply("hello") =&gt; "HELLO"</pre>
</p>
</li><li><p  id="Better_loops"><strong>Better loops</strong>
<p>Lambda expressions are especially useful when working with collections. For example, when applying side effects from a collection it is often better to use the implicit <code>forEach</code> extension method instead of a loop:</p>
<pre class="prettyprint lang-spec">
list("red", "blue", "green").forEach[println]</pre>
</p>
</li><li><p  id="Filter_iterables_by_type"><strong>Filter iterables by type</strong>
<p>The <code>filter</code> extension method is really helpful when you are only interested in a subset of a collection. You can filter by type:</p>
<pre class="prettyprint lang-spec">
list("a string", 42, true).filter(typeof(String)) =&gt; iterable("a string")</pre>
</p>
</li><li><p  id="____or_via_a_custom_predicate"><strong>... or via a custom predicate</strong>
<p>In this case we provide a lambda expressions that returns true for the elements we are interested in:</p>
<pre class="prettyprint lang-spec">
list("red", "blue", "green").filter[startsWith("b")] =&gt; list("blue")</pre>
</p>
</li><li><p  id="Map_Reduce_made_easy"><strong>Map/Reduce made easy</strong>
<p>This examples demonstrates how you can realize complex operations by composing different functions. Here we are counting all characters in a list of Strings using the <code>map</code> and <code>reduce</code> extension methods.</p>
<pre class="prettyprint lang-spec">
val strings = list("red", "blue", "green")
val charCount = strings.map[s|s.length].reduce[sum, size | sum + size]
charCount =&gt; 12</pre>
</p>
</li></ul>
				</div>
			</div>
		</div> <!-- /content -->
		<footer>
			<p><small>Generated by <a href="http://www.jnario.org">Jnario</a>.</small></p>
		</footer>

	</div>
	<!-- /container -->

</body>
</html>
